// index.js
const { default: makeWASocket, useSingleFileAuthState, DisconnectReason } = require("@whiskeysockets/baileys");
const pino = require("pino");
const { Boom } = require("@hapi/boom");
const fs = require("fs");
const { SESSION_ID } = process.env; // from config.env
const { exec } = require("child_process");

// Use a single file auth state to store login
const { state, saveState } = useSingleFileAuthState(`./session.json`);

async function startBot() {
    const sock = makeWASocket({
        logger: pino({ level: "silent" }),
        auth: state,
        browser: ["FAITH47-MD", "Chrome", "4.0"]
        // note: no printQRInTerminal here
    });

    // save state on any auth update
    sock.ev.on("creds.update", saveState);

    sock.ev.on("connection.update", (update) => {
        const { connection, lastDisconnect } = update;
        if(connection === "close") {
            const reason = new Boom(lastDisconnect?.error)?.output.statusCode;
            console.log("Connection closed, reason:", reason);
            // reconnect automatically if not logged out
            if(reason !== DisconnectReason.loggedOut) {
                startBot();
            }
        } else if(connection === "open") {
            console.log("✅ Bot is online!");
        }
    });

    // Example command
    sock.ev.on("messages.upsert", async (m) => {
        const msg = m.messages[0];
        if(!msg.message || msg.key.fromMe) return;

        const from = msg.key.remoteJid;
        const text = msg.message.conversation || msg.message.extendedTextMessage?.text;

        if(!text) return;

        if(text.toLowerCase() === "ping") {
            await sock.sendMessage(from, { text: "Pong!" });
        }
    });
}

// Check SESSION_ID exists
if(!SESSION_ID) {
    console.error("❌ SESSION_ID not found in config.env. Run session.js and sessionToString.js first!");
    process.exit(1);
}

startBot();
